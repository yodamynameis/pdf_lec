# Generated by pipeline_to_manim_720p.py â€” Manim v0.19.0
from manim import *
from manim import config
# Setting configuration for 1080p output (Manim default aspect ratio is 16:9)
config.pixel_width = 1920
config.pixel_height = 1080
config.frame_rate = 30

class CircleVsEllipse(Scene):
    def construct(self):
        # Apply the methods in sequence
        self.scene_introduction()
        self.scene_defining_circle()
        self.scene_defining_ellipse()
        self.scene_equation_circle()
        self.scene_equation_ellipse()
        self.scene_conclusion()

    # --- Scene 1: Introduction ---
    def scene_introduction(self):
        title = Text("Circle vs Ellipse")
        title.to_edge(UP)
        self.play(Write(title))

        # Use an object-oriented approach for the conic section frame
        cone = VGroup(
            Cone(height=5, base_radius=1.5, direction=UP, fill_opacity=0.3, color=YELLOW_A),
            Cone(height=5, base_radius=1.5, direction=DOWN, fill_opacity=0.3, color=YELLOW_A)
        ).scale(0.8)
        
        rect = Rectangle(height=4, width=7, color=BLUE).set_opacity(0.1)
        
        # Text positioning
        text_conic = Text("Part of Conic Sections").next_to(cone, DOWN, buff=0.8)

        # Draw the cone and explain the concept
        self.play(Create(cone), FadeIn(rect))
        self.play(Write(text_conic))
        self.wait(1.5)

        # Clear the scene
        self.play(
            FadeOut(title, rect, text_conic),
            cone.animate.scale(0.1).shift(UP*10), # Animate cone away nicely
            run_time=1
        )
        self.wait(0.5)

    # --- Scene 2: Defining Circle ---
    def scene_defining_circle(self):
        # Title
        title = Text("1. Definition: Circle").to_edge(UP).scale(1.2)
        self.play(Write(title))

        # Circle and Center
        circle = Circle(radius=2, color=WHITE)
        # FIX: Ensure 3D coordinates using ORIGIN to avoid ValueError
        center_dot = Dot(point=ORIGIN, color=RED) 
        text_center = Text("Center (Fixed Point)").next_to(center_dot, DOWN, buff=0.5)
        text_center.shift(LEFT * 0.5)

        self.play(Create(circle), Create(center_dot))
        self.play(Write(text_center))

        # Radius line and text
        point_on_circle = circle.point_at_angle(PI/4)
        line_radius = Line(center_dot.get_center(), point_on_circle, color=BLUE)
        text_radius = Text("Radius (Constant Distance)", color=BLUE).next_to(line_radius, RIGHT, buff=0.1).shift(UP*0.2)
        
        self.play(Create(line_radius), Write(text_radius))
        self.wait(0.5)

        # Show the radius moving
        mobile_point = Dot(point_on_circle, color=YELLOW)
        self.add(mobile_point)

        def update_line(mobj):
            mobj.become(Line(center_dot.get_center(), mobile_point.get_center(), color=BLUE))

        line_radius.add_updater(update_line)
        self.play(MoveAlongPath(mobile_point, circle), rate_func=linear, run_time=3)
        line_radius.remove_updater(update_line)
        
        self.wait(1)

        # Clear the scene
        self.play(FadeOut(circle, center_dot, text_center, line_radius, text_radius, mobile_point, title))
        self.wait(0.5)

    # --- Scene 3: Defining Ellipse ---
    def scene_defining_ellipse(self):
        # Title
        title = Text("2. Definition: Ellipse").to_edge(UP).scale(1.2)
        self.play(Write(title))

        # Ellipse and Foci
        ellipse = Ellipse(width=6, height=4, color=WHITE)
        self.play(Create(ellipse))
        
        # Calculate foci for the ellipse (c^2 = a^2 - b^2)
        a = 3.0 # half width
        b = 2.0 # half height
        c = (a**2 - b**2)**0.5 # distance from center to focus
        
        focus1 = Dot(point=[-c, 0, 0], color=RED)
        focus2 = Dot(point=[c, 0, 0], color=RED)
        self.play(Create(focus1), Create(focus2))

        # Focus labels
        text_focus1 = Text("Focus 1").next_to(focus1, DOWN*1.5)
        text_focus2 = Text("Focus 2").next_to(focus2, DOWN*1.5)
        text_foci_group = VGroup(text_focus1, text_focus2)

        self.play(Write(text_foci_group))

        # Moving point on the ellipse
        mobile_point_initial = ellipse.point_at_angle(PI/2) # Start at top
        mobile_point = Dot(mobile_point_initial, color=YELLOW)
        self.add(mobile_point)

        # Line segments from foci to the mobile point
        line1 = Line(focus1.get_center(), mobile_point.get_center(), color=BLUE)
        line2 = Line(focus2.get_center(), mobile_point.get_center(), color=GREEN)
        self.add(line1, line2)

        # Sum text (T_1 + T_2 = Constant)
        text_sum = MathTex("d_1", "+", "d_2", "=", "2a").to_edge(UP).shift(DOWN*1.2).scale(1.2)
        text_sum[0].set_color(BLUE)
        text_sum[2].set_color(GREEN)
        self.play(Write(text_sum))
        
        # Updaters to show the constant sum property
        def update_lines(mobj):
            mobj[0].become(Line(focus1.get_center(), mobile_point.get_center(), color=BLUE))
            mobj[1].become(Line(focus2.get_center(), mobile_point.get_center(), color=GREEN))

        lines = VGroup(line1, line2)
        lines.add_updater(update_lines)

        self.play(MoveAlongPath(mobile_point, ellipse), rate_func=linear, run_time=5)
        
        lines.remove_updater(update_lines)
        
        self.wait(1)

        # Clear the scene
        self.play(FadeOut(ellipse, focus1, focus2, text_foci_group, mobile_point, lines, text_sum, title))
        self.wait(0.5)

    # --- Scene 4: Equation Circle ---
    def scene_equation_circle(self):
        # Title
        title = Text("3. Equation: Circle").to_edge(UP).scale(1.2)
        self.play(Write(title))

        # Axes in the center
        axes = Axes(
            x_range=[-3, 3, 1],
            y_range=[-3, 3, 1],
            x_length=6,
            y_length=6,
            axis_config={"include_numbers": True}
        ).to_edge(LEFT, buff=1.5)
        
        # Circle on the axes
        circle = Circle(radius=2, color=BLUE).move_to(axes.get_origin())

        # Equation label
        equation = MathTex(
            "x^2 + y^2 = r^2",
            substrings_to_isolate=['r']
        ).to_edge(RIGHT, buff=1.5)
        equation.scale(1.5)
        equation.submobjects[2].set_color(RED) # color the 'r'

        self.play(Create(axes), Create(circle))
        self.play(Write(equation))
        
        # Highlight radius on the graph
        radius_line = Line(axes.get_origin(), axes.c2p(2, 0), color=RED, stroke_width=8)
        text_r = MathTex("r").next_to(radius_line, DOWN, buff=0.2)
        
        self.play(Create(radius_line), Write(text_r))
        self.wait(1.5)

        # Clear the scene
        self.play(FadeOut(title, equation, axes, circle, radius_line, text_r))
        self.wait(0.5)

    # --- Scene 5: Equation Ellipse ---
    def scene_equation_ellipse(self):
        # Title
        title = Text("4. Equation: Ellipse").to_edge(UP).scale(1.2)
        self.play(Write(title))

        # Axes in the center
        axes = Axes(
            x_range=[-4, 4, 1],
            y_range=[-4, 4, 1],
            x_length=7,
            y_length=7,
            axis_config={"include_numbers": True}
        ).to_edge(LEFT, buff=1.5)
        
        # Ellipse on the axes (width=5, height=3 in original; adjusted to 6, 4 for easier visualization)
        ellipse = Ellipse(width=6, height=4, color=BLUE).move_to(axes.get_origin())
        a_val = 3.0
        b_val = 2.0

        # Equation label
        equation = MathTex(
            "{x^2", "\\over", "a^2}", "+", "{y^2", "\\over", "b^2}", "= 1",
            substrings_to_isolate=['a', 'b']
        ).to_edge(RIGHT, buff=1.5)
        equation.scale(1.5)
        equation.get_parts_by_tex('a')[0].set_color(GREEN)
        equation.get_parts_by_tex('b')[0].set_color(RED)

        self.play(Create(axes), Create(ellipse))
        self.play(Write(equation))

        # Semi-major axis (a) - Horizontal
        arrow_a = Arrow(start=axes.c2p(0,0), end=axes.c2p(a_val, 0), color=GREEN, buff=0).shift(DOWN*0.1)
        text_a = MathTex("a").next_to(arrow_a, DOWN)
        self.play(Create(arrow_a), Write(text_a))

        # Semi-minor axis (b) - Vertical
        arrow_b = Arrow(start=axes.c2p(0,0), end=axes.c2p(0, b_val), color=RED, buff=0).shift(RIGHT*0.1)
        text_b = MathTex("b").next_to(arrow_b, RIGHT)
        self.play(Create(arrow_b), Write(text_b))
        
        self.wait(1.5)

        # Clear the scene
        self.play(FadeOut(title, equation, axes, ellipse, arrow_a, text_a, arrow_b, text_b))
        self.wait(0.5)

    # --- Scene 6: Conclusion ---
    def scene_conclusion(self):
        # Create a table/VGroup for comparison
        header = VGroup(
            Text("Feature").scale(1.1).set_color(YELLOW),
            Text("Circle").scale(1.1).set_color(BLUE),
            Text("Ellipse").scale(1.1).set_color(GREEN)
        ).arrange(RIGHT, buff=2)

        row1 = VGroup(
            Text("Definition"),
            Text("1 Fixed Distance (Radius)"),
            Text("Constant Sum of 2 Distances (Foci)")
        ).arrange(RIGHT, buff=1.05)
        
        # Define MathTex objects for the variables row separately for easier access
        math_r = MathTex("r")
        math_ab = MathTex("a", ",", "b")

        row2 = VGroup(
            Text("Variables"),
            math_r, # Use the defined object
            math_ab # Use the defined object
        ).arrange(RIGHT, buff=2.2)
        
        # FIX: Color the parts by calling the method on the MathTex object, not the VGroup
        # math_ab is the third item in VGroup, but here we access it directly.
        math_ab.get_parts_by_tex('a')[0].set_color(GREEN)
        math_ab.get_parts_by_tex('b')[0].set_color(RED)


        row3 = VGroup(
            Text("Equation"),
            MathTex("x^2 + y^2 = r^2").scale(0.9),
            MathTex("\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1").scale(0.9)
        ).arrange(RIGHT, buff=1.2)
        
        # Group all rows and position them
        table = VGroup(header, row1, row2, row3).arrange(DOWN, aligned_edge=LEFT, buff=0.8)
        table.move_to(ORIGIN)

        self.play(
            Write(header),
            runtime=1
        )
        self.play(
            LaggedStart(*[Write(mob) for mob in row1]),
            runtime=1.5
        )
        self.play(
            LaggedStart(*[Write(mob) for mob in row2]),
            runtime=1.5
        )
        self.play(
            LaggedStart(*[Write(mob) for mob in row3]),
            runtime=1.5
        )

        self.wait(2)

        # Final FadeOut
        self.play(FadeOut(table))
        self.wait(0.5)

        # Thank you text
        thank_you_text = Text("Thank You for Watching!", color=GREEN).scale(1.5)
        self.play(Write(thank_you_text))
        self.wait(1)
        self.play(FadeOut(thank_you_text))