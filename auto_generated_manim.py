# Generated by pipeline_to_manim_720p.py â€” Manim v0.19.0
from manim import *
import numpy as np

config.pixel_width = 1920
config.pixel_height = 1080
config.frame_rate = 30

class AutoGeneratedVideo(Scene):
    def construct(self):
        ### SCENE 1: The Dimension Rule ###

        # Create and position title
        title1 = Text("The Dimension Rule")
        title1.to_edge(UP)
        self.play(Write(title1))
        self.wait(0.5)

        # Create matrix A representation
        label_A = Text("Matrix A")
        matrix_A_text = Text("[[*, *], [*, *], [*, *]]").scale(1.2)
        group_A = VGroup(label_A, matrix_A_text).arrange(DOWN, buff=0.3)

        # Create matrix B representation
        label_B = Text("Matrix B")
        matrix_B_text = Text("[[*, *, *], [*, *, *]]").scale(1.2)
        group_B = VGroup(label_B, matrix_B_text).arrange(DOWN, buff=0.3)
        
        # Position matrices side-by-side
        matrices_group = VGroup(group_A, group_B).arrange(RIGHT, buff=2.5).center().shift(DOWN*0.5)
        self.play(FadeIn(matrices_group))
        self.wait(0.5)

        # Create dimension texts from parts to allow highlighting
        dim_A_part1 = Text("3 rows, ")
        dim_A_part2 = Text("2 columns")
        dim_A = VGroup(dim_A_part1, dim_A_part2).arrange(RIGHT, buff=0.15).next_to(group_A, DOWN, buff=0.3)

        dim_B_part1 = Text("2 rows")
        dim_B_part2 = Text(", 3 columns")
        dim_B = VGroup(dim_B_part1, dim_B_part2).arrange(RIGHT, buff=0.15).next_to(group_B, DOWN, buff=0.3)

        self.play(Write(dim_A), Write(dim_B))
        self.wait(0.5)

        # Highlight inner dimensions
        rect_A = SurroundingRectangle(dim_A_part2, color=YELLOW, buff=0.2)
        rect_B = SurroundingRectangle(dim_B_part1, color=YELLOW, buff=0.2)
        self.play(Create(rect_A), Create(rect_B))
        self.wait(0.5)
        
        # Show "Match!" text
        match_text = Text("Match!", color=GREEN).next_to(rect_A, RIGHT, buff=0.8).align_to(rect_B, UP)
        self.play(Write(match_text))
        self.wait(0.5)

        # Show result dimension derivation
        result_placeholder = VGroup(rect_A, rect_B, match_text).get_center() + DOWN*2.5
        arrow1 = Arrow(dim_A_part1.get_edge_center(DOWN), result_placeholder, buff=0.2)
        arrow2 = Arrow(dim_B_part2.get_edge_center(DOWN), result_placeholder, buff=0.2)
        result_text = Text("Result: 3x3 matrix").next_to(result_placeholder, DOWN, buff=0.2)
        
        self.play(GrowArrow(arrow1), GrowArrow(arrow2))
        self.play(Write(result_text))
        self.wait(1)

        # Transition to Scene 2
        scene1_mobs = VGroup(title1, matrices_group, dim_A, dim_B, rect_A, rect_B, match_text, arrow1, arrow2, result_text)
        self.play(FadeOut(scene1_mobs))
        self.wait(0.5)


        ### SCENE 2: The Row-by-Column Operation ###
        
        # Create and position title
        title2 = Text("The Row-by-Column Operation")
        title2.to_edge(UP)
        self.play(Write(title2))
        self.wait(0.5)

        # --- FIX: Added lambda to convert int to str before creating Text mobjects ---
        matrix_A = Matrix(
            [[2, 1], [3, 4], [5, 6]], 
            element_to_mobject=lambda t: Text(str(t)), 
            h_buff=1.5, v_buff=1.3
        ).scale(0.9)
        
        matrix_B = Matrix(
            [[7, 8, 9], [10, 11, 12]], 
            element_to_mobject=lambda t: Text(str(t)), 
            h_buff=1.5, v_buff=1.3
        ).scale(0.9)
        # -----------------------------------------------------------------------------
        
        # Position matrices side-by-side
        num_matrices_group = VGroup(matrix_A, matrix_B).arrange(RIGHT, buff=1.5).center()
        self.play(Write(num_matrices_group))
        self.wait(0.5)

        # Highlight first row of A and first column of B
        row1_A = matrix_A.get_rows()[0]
        col1_B = matrix_B.get_columns()[0]
        highlight_row1_A = SurroundingRectangle(row1_A, color=BLUE, buff=0.2)
        highlight_col1_B = SurroundingRectangle(col1_B, color=RED, buff=0.2)
        self.play(Create(highlight_row1_A), Create(highlight_col1_B))
        self.wait(0.5)

        # Draw arrows connecting corresponding elements
        arrow_2_7 = Arrow(row1_A[0].get_center(), col1_B[0].get_center(), buff=0.1, color=YELLOW)
        arrow_1_10 = Arrow(row1_A[1].get_center(), col1_B[1].get_center(), buff=0.1, color=YELLOW)
        self.play(GrowArrow(arrow_2_7), GrowArrow(arrow_1_10))
        self.wait(0.5)

        # Show the calculation expression
        calc_text_parts = VGroup(Text("(2 * 7)"), Text(" + "), Text("(1 * 10)")).arrange(RIGHT, buff=0.2)
        calc_text_parts.to_edge(DOWN, buff=1.0)
        self.play(Write(calc_text_parts))
        self.wait(1)

        # Store objects for next scene
        scene2_to_3_mobs = VGroup(arrow_2_7, arrow_1_10)


        ### SCENE 3: Calculating the First Element ###
        
        # Fade out previous title and write new one
        self.play(FadeOut(title2, shift=UP))
        title3 = Text("Calculating the First Element").to_edge(UP)
        self.play(Write(title3))
        self.wait(0.5)

        # Simplify the expression
        calc_step2 = Text("14 + 10").move_to(calc_text_parts)
        self.play(Transform(calc_text_parts, calc_step2))
        self.wait(0.5)

        calc_step3 = Text("24").move_to(calc_text_parts)
        self.play(Transform(calc_text_parts, calc_step3))
        self.wait(0.5)
        
        # Fade out arrows
        self.play(FadeOut(scene2_to_3_mobs))
        self.wait(0.2)

        # Create placeholder for result matrix C
        equals_sign = Text("=").next_to(num_matrices_group, RIGHT, buff=0.7)
        matrix_C_placeholder = Matrix(
            [["?", "?", "?"], ["?", "?", "?"], ["?", "?", "?"]],
            element_to_mobject=Text, # Here '?' is already a string, so Text works fine
            h_buff=2.0, v_buff=1.3
        ).scale(0.9)
        matrix_C_placeholder.next_to(equals_sign, RIGHT, buff=0.7)
        self.play(Write(equals_sign), Create(matrix_C_placeholder))
        self.wait(0.5)

        # Move the result '24' to the correct position in C
        first_element_q = matrix_C_placeholder.get_entries()[0]
        result_24_final = calc_text_parts
        self.play(ReplacementTransform(first_element_q, result_24_final.move_to(first_element_q)))
        self.wait(1)

        # Transition to Scene 4: fade highlights
        highlights_scene3 = VGroup(highlight_row1_A, highlight_col1_B)
        self.play(FadeOut(highlights_scene3))
        self.wait(0.5)


        ### SCENE 4: Completing the Matrix ###
        
        # Fade out previous title and write new one
        self.play(FadeOut(title3, shift=UP))
        title4 = Text("Completing the Matrix").to_edge(UP)
        self.play(Write(title4))
        self.wait(0.5)

        # Highlight first row of A and second column of B
        row1_A = matrix_A.get_rows()[0]
        col2_B = matrix_B.get_columns()[1]
        highlight_row1_A = SurroundingRectangle(row1_A, color=BLUE, buff=0.2)
        highlight_col2_B = SurroundingRectangle(col2_B, color=RED, buff=0.2)
        self.play(Create(highlight_row1_A), Create(highlight_col2_B))
        self.wait(0.5)

        # Show calculation for the second element
        calc2_text = Text("(2*8) + (1*11) = 27").to_edge(DOWN, buff=1.0)
        self.play(Write(calc2_text))
        self.wait(0.5)

        result_27_obj = Text("27").move_to(calc2_text.get_center())
        self.play(Transform(calc2_text, result_27_obj))
        self.wait(0.2)
        
        second_element_q = matrix_C_placeholder.get_entries()[1]
        self.play(ReplacementTransform(second_element_q, calc2_text.move_to(second_element_q)))
        self.wait(0.5)

        # Quickly fill the rest of the matrix
        current_highlights = VGroup(highlight_row1_A, highlight_col2_B)
        
        C_vals = [[24, 27, 30], [61, 76, 92], [93, 114, 135]]
        c_entries_q = matrix_C_placeholder.get_entries()
        
        for i in range(3):
            for j in range(3):
                if (i==0 and j==0) or (i==0 and j==1):
                    continue
                
                self.play(FadeOut(current_highlights), run_time=0.3)
                current_highlights = VGroup(
                    SurroundingRectangle(matrix_A.get_rows()[i], color=BLUE, buff=0.2),
                    SurroundingRectangle(matrix_B.get_columns()[j], color=RED, buff=0.2)
                )
                self.play(Create(current_highlights), run_time=0.3)
                
                entry_index = i * 3 + j
                q_mark_to_replace = c_entries_q[entry_index]
                result_val = Text(str(C_vals[i][j])).move_to(q_mark_to_replace.get_center())
                self.play(ReplacementTransform(q_mark_to_replace, result_val), run_time=0.5)
                self.wait(0.1)

        self.play(FadeOut(current_highlights))
        self.wait(0.5)

        # Group final equation and arrange
        final_C_entries = VGroup(*[m for m in self.mobjects if isinstance(m, Text) and m.text.isdigit()])
        
        # --- FIX: Added lambda here as well since C_vals contains integers ---
        final_C = Matrix(
            np.array(C_vals).reshape(3,3), 
            element_to_mobject=lambda t: Text(str(t)), 
            h_buff=2.0, v_buff=1.3
        ).scale(0.9)
        # ---------------------------------------------------------------------

        final_C.move_to(matrix_C_placeholder.get_center())
        
        self.remove(*final_C_entries) # remove individual numbers
        self.add(final_C) # add the clean Matrix object

        full_equation = VGroup(matrix_A, Text("*").scale(1.5), matrix_B, equals_sign, final_C)
        full_equation.arrange(RIGHT, buff=0.4)
        
        # Reposition all elements to be centered
        self.play(
            matrix_A.animate.move_to(full_equation[0].get_center()),
            matrix_B.animate.move_to(full_equation[2].get_center()),
            equals_sign.animate.move_to(full_equation[3].get_center()),
            final_C.animate.move_to(full_equation[4].get_center()),
            FadeIn(full_equation[1].move_to(VGroup(matrix_A, matrix_B).get_center())),
            FadeOut(matrix_C_placeholder.get_brackets())
        )
        self.wait(0.5)

        self.play(self.camera.frame.animate.scale(1.2).move_to(full_equation))
        self.wait(1)


        ### SCENE 5: Summary and Key Points ###
        
        # Fade out previous title and write new one
        self.play(FadeOut(title4, shift=UP))
        title5 = Text("Summary and Key Points").to_edge(UP)
        self.play(Write(title5))
        self.wait(0.5)
        
        # Position equation slightly up to make room for points
        self.play(full_equation.animate.center().shift(UP*1.0))
        self.wait(0.5)

        # Create and animate bullet points
        rule1 = Text("- Rule 1: Columns of A must equal Rows of B")
        rule2 = Text("- Rule 2: Result element is from one Row x one Column")
        rules = VGroup(rule1, rule2).arrange(DOWN, buff=0.6, aligned_edge=LEFT).next_to(full_equation, DOWN, buff=1.0)
        
        self.play(Write(rule1))
        self.wait(0.5)
        
        # Flash inner dimensions
        flash_cols = SurroundingRectangle(matrix_A.get_columns(), color=YELLOW, buff=0.3)
        flash_rows = SurroundingRectangle(matrix_B.get_rows(), color=YELLOW, buff=0.3)
        self.play(ShowPassingFlash(flash_cols, time_width=1.0), ShowPassingFlash(flash_rows, time_width=1.0))
        self.wait(0.5)
        
        self.play(Write(rule2))
        self.wait(0.5)

        # Reinforce Row x Column concept
        highlight_A_row3 = SurroundingRectangle(matrix_A.get_rows()[2], color=BLUE, buff=0.2)
        highlight_B_col2 = SurroundingRectangle(matrix_B.get_columns()[1], color=RED, buff=0.2)
        highlight_C_val = SurroundingRectangle(final_C.get_entries()[7], color=GREEN, buff=0.2) # C[2][1] is index 7

        self.play(Create(highlight_A_row3), Create(highlight_B_col2))
        self.wait(0.5)
        self.play(Create(highlight_C_val))
        self.wait(2)

        # Fade to black
        self.play(FadeOut(*self.mobjects))
        self.wait(1)